---
layout: post
title: "Scaling Schema Changes"
date: 2011-11-10 16:06
comments: true
categories: ["django", "disqus"]
---

<p>I frequently get asked how Disqus deals with schema changes. It's a fair question, since we operate a fairly large amount of servers, but I also tend to think the answer is somewhat obvious. So let's start with the problem of schema changes at scale (in PostgreSQL).</p>

<p>Generally you have some table, let's call it a profile (since people seem to enjoy changing those). Well today, a new service has launched called Twooter, and we want to denormalize the user's Twooter name into their profile. To do this we need to add a new field, <code>twooter_username</code>.</p>

<h2>DDL First</h2>

<p>The first thing we have to realize, is that <strong>everyone will not have <code>twooter_username</code></strong>. Now even if that weren't true, it needs to be to maintain compatibility, and efficiency. For us, this means that <strong>all additions must be made as NULLable columns</strong>. This means that the old code can stay in place whether the schema change has been made or not, and more importantly, NULLable ALTERs are <strong>much</strong> quicker in Postgres.</p>

<p>It's very important that the schema change is made <strong>before</strong> the application's new version is deployed. Ideally you want to do the change as soon as the schema is finalized. I'll talk more a bit about the reasons for that later.</p>

<h2>Application Changes</h2>

<p>The second thing we need to concern ourselves with is our application logic. As I said before you <strong>must</strong> do the DDL before deploying your code changes. For us, this means all <strong>DDL happens in a branch</strong>, and can be merged once the change is completed. I also mentioned that additions must be NULLable, which not only means we can do the schema change before updating our application, but we also ensure forwards <strong>and</strong> backwards compatibility.</p>

<p>In addition to waiting for the schema change to complete before deploying your application, some changes may require several other steps along the release process. As an example, maybe we already had <code>twooter_username</code> stored in a different table, and we were literally just moving it to optimize our data access. This happens with a two things:</p>

<ul>
    <li>A write-through cache in the application to ensure <strong>new</strong> data is stored.</li>
    <li>A backfill operation to ensure old data is stored (this also must be idempotent).</li>
</ul>

<p>Once we've taken care of the above steps, only then can we actually utilize read operations on this new data. What this generally means is multi-step process to add a new data pattern:</p>

<ol>
    <li>Perform DDL.</li>
    <li>Deploy write-through cache code.</li>
    <li>Run backfill operation.</li>
    <li>Run sanity checks (verify the data is correct, and exists).</li>
    <li>Deploy code which utilizes new data.</li>
</ol>

<h2>DDL on a Cluster</h2>

<p>I've mostly been talking about how we scale the application side (read: code) for our DDL changes, but it's also important to note how we do no-downtime schema changes. For this there are two important concepts we utilize: platform-wide read-only mode, and enough capacity to remove a node from the cluster. The last part is important: <strong>enough capacity to remove a node from the cluster</strong>.</p>

<p>Now let's say this <code>twooter_username</code> is going to be added to a table which is so large, that even a fast NULLable ALTER cannot be run in production. In this case we're actually going to need to swap out our master PG node to ensure we don't hit any downtime, or slowness while making these changes. This is where read-only mode comes into play. It looks something like this:</p>

<ol>
    <li>Take a slave out of the pool.</li>
    <li>Run DDL on slave.</li>
    <li>Put it back into the pool.</li>
    <li>(repeat on all slaves)</li>
    <li>Turn on read-only.</li>
    <li>Promote a slave to master.</li>
    <li>(repeat DDL operation on former-master)</li>
</ol>

<p>And that's all there is to it. I'd be curious to hear if anyone else is doing things differently.</p>